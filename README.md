# CapyMaze Quest ğŸ¦¦

**CapyMaze Quest** is a retro-styled procedural maze game built with **React**, **PixiJS**, and **Google Gemini API**. Navigate a capybara through infinite mazes, avoid predators, and unlock gates by solving AI-generated trivia questions.

## ğŸ® Game Overview

The player controls a Capybara using the keyboard. The goal of each level is to find the **Pond**.

*   **Grid:** Procedurally generated using a recursive backtracker algorithm.
*   **Hazards:** Predators (Jaguars/Anacondas/Caimans) patrol the maze. Contact loses a life.
*   **Bonuses:** Treats (Corn, Pumpkin, Watermelon) increase score.
*   **Gates:** Wooden logs block paths. To pass, you must answer a trivia question generated by the Gemini API based on a user-selected topic.
*   **Progression:** Levels get progressively generated. Completing a level triggers a celebration sequence.

## ğŸ— Architecture

The application separates **Game State/Logic** from **React UI Rendering** using a hybrid approach.

### 1. The React Layer (`App.tsx`, `components/`)
*   **Responsibility:** Handles high-level application states (Menu, Playing, Game Over, Level Complete).
*   **UI Overlays:** Renders the HUD (Heads-up Display) for score/lives and the Trivia Modal.
*   **Service Integration:** Calls the Gemini Service for trivia, managing a background cache to ensure questions load instantly.

### 2. The Game Engine (`classes/GameEngine.ts`)
*   **Responsibility:** Manages the PixiJS Application, the HTML Canvas, and the frame-by-frame game loop.
*   **Rendering:** Uses `pixi.js` to render the grid, walls, and entities as Sprites.
*   **Physics:** Handles collision detection (AABB/Distance check) and movement interpolation.
*   **Event Bridge:** Communicates with React via a callback system (e.g., triggering the Trivia modal when a gate is hit).

### 3. Services
*   **`levelGenerator.ts`:** Pure logic for creating maze arrays (`number[][]`) and placing entities.
*   **`geminiService.ts`:** Interfaces with Google's GenAI SDK to fetch structured JSON trivia data.
*   **`quizService.ts`:** Manages trivia question caching, pre-fetching, and delivery to the game.

## ğŸ›  Tech Stack

*   **Frontend Framework:** React 19
*   **Rendering Engine:** PixiJS (v8)
*   **Styling:** TailwindCSS
*   **AI:** Google Gemini API (`gemini-2.5-flash`)
*   **Language:** TypeScript

## ğŸ“‚ Project Structure

```
â”œâ”€â”€ classes/
â”‚   â””â”€â”€ GameEngine.ts       # Core PixiJS game loop and renderer
â”œâ”€â”€ components/
â”‚   â”œâ”€â”€ Game.tsx            # React wrapper for GameEngine + UI Overlays
â”‚   â””â”€â”€ MainMenu.tsx        # Config screen
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ geminiService.ts    # AI Generation
â”‚   â”œâ”€â”€ quizService.ts      # Quiz Cache & Delivery
â”‚   â””â”€â”€ levelGenerator.ts   # Maze Algorithms
â”œâ”€â”€ constants.ts            # Config, Assets, Translations
â”œâ”€â”€ types.ts                # TypeScript interfaces and Enums
â””â”€â”€ App.tsx                 # Main State Controller
```

## ğŸ§© Key Programming Patterns

### The "Engine-Bridge" Pattern
Because PixiJS runs on its own `requestAnimationFrame` ticker, passing React state down to it on every frame is inefficient. Instead:
1.  React instantiates `GameEngine` inside a `useEffect` (on mount).
2.  React subscribes to events from the Engine (`GATE_HIT`, `GAME_OVER`).
3.  React calls public methods on the Engine (`engine.loadLevel()`, `engine.resume()`).

### Procedural Generation
The maze uses a **Recursive Backtracker** algorithm ensuring a perfect maze (no loops, all accessible). We then run a post-processing pass to remove ~40% of walls to create loops, making the gameplay more dynamic and less frustrating.

### AI Integration & Caching
The `geminiService` requests JSON-structured data (`responseMimeType: "application/json"`). To prevent gameplay interruptions, the `quizService` maintains a **trivia cache**:
1.  On game start, a batch of 20 questions is fetched.
2.  As the player consumes questions, the service triggers background re-fetches when the cache drops below 5 items.

## ğŸ¨ Visuals & Assets

*   **Style:** Retro Pixel Art vibe.
*   **Font:** `VT323` (Google Fonts).
*   **Assets:** The game uses hosted pixel-art PNG assets for the Capybara, Predators, and Treats.
*   **Procedural Textures:** The Game Engine generates specific textures (like dirt and water) at runtime using `PIXI.Graphics` to ensure crisp pixel scaling.

## ğŸš€ Development Guidelines

1.  **Modifying the Game Loop:** Edit `GameEngine.ts`. The `update()` method runs every frame.
2.  **Changing Assets:** Update `constants.ts`.
3.  **Adding Languages:** Add entries to `TRANSLATIONS` in `constants.ts`. The logic automatically handles localized strings.

## âš ï¸ Common Pitfalls

*   **React Strict Mode:** React 18+ mounts components twice in dev. The `useEffect` in `Game.tsx` has cleanup logic (`engine.destroy()`) to prevent two Canvases from appearing.
*   **Grid Access:** Always check bounds when moving entities. The logic `if (grid[y] && grid[y][x])` prevents generic "undefined" errors.

---
*Created by a Senior Frontend AI Engineer.*